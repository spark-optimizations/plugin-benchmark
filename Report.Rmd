---
title: "Spark Join Optimizations"
author: "Shabbir Hussain, Manthan Thakar, Tirthraj Parmar"
date: "December 5, 2017"
output:
  html_document:
    df_print: paged
  pdf_document:
    fig_crop: no
    fig_width: 5
    latex_engine: xelatex
geometry: left=1cm,right=1cm,top=1cm,bottom=2cm
---

# Objective

Optimizing Spark joins on Resilient Distributed Datasets (RDDs) by employing column-pruning and / or broadcast join wherever appropriate.

# Join Optimization

Join operation on RDDs can be expensive. We suspect that one of the biggest factors that affects join performance is the amount of data shuffled in the process. In order to alleviate excessive shuffling of data, we propose and implement two types of optimizations, namely, **Column Pruning** and **Broadcast Join**. In the following sections, we discuss both of these approaches and present our findings.

## Optimization 1: Column Pruning

**Hypothesis**: 

### Approach

### Benchmarks

## Optimization 2: Broadcast Join

**Hypothesis**:

### Approach

### Benchmarks

```{r setup, echo=F, results='hide', message=F, warning=F, cache=F}
library("ggplot2")
library("tidyr")
library("knitr")
library("kableExtra")
library("scales")
library("plyr")
library("microbenchmark")
library("reshape2")
library("readr")
library("tm")
library("SnowballC")
library("wordcloud")
library("RColorBrewer")
library("grid")
library("gridBase")
library("gridExtra")
library("dplyr")
```

```{r echo=F, cache=TRUE, results='hide'}
data <- read.csv('results/timing_stats.csv', sep="\t", header = FALSE)
data <- data[, c("V1", "V3", "V4")]
```

```{r echo=F, message=F, warning=F, cache=TRUE, results='hide'}
dataRun <- subset(data, (substring(data$V1, 0, 3) == "run") & data$V3=="real")
dataRun$V1 <- substring(dataRun$V1, 5)
dataRun %>%
  group_by(V1) %>% 
  summarise(Mean=mean(V4), Median=median(V4)) %>%
  separate("V1", into = paste("V", 1:3, sep = "_")) -> dataRun

colnames(dataRun) <- c("Type", "Tot", "Used", "TimeMean", "TimeMedian")
dataRun$Tot <- as.integer(dataRun$Tot)
dataRun$Used <- as.integer(dataRun$Used)
dataRun <- subset(dataRun, Tot!=0)

dfReg <- subset(dataRun, Type=="reg")
dfPlu <- subset(dataRun, Type=="plugin")

dMin <- min(dataRun$TimeMedian)
dMax <- max(dataRun$TimeMedian)

g_legend<-function(aGplot){
    tmp <- ggplot_gtable(ggplot_build(aGplot))
    leg <- which(sapply(tmp$grobs, function(x) x$name) == "guide-box")
    legend <- tmp$grobs[[leg]]
    legend
}

gen_plot <- function(df, title){
  ggplot(data=df, aes(x=reorder(as.factor(Tot), Tot), y=reorder(as.factor(Used), Used), fill=TimeMedian)) +
      geom_tile(width=1, height=1) + 
      scale_fill_gradient(low="white", high="red", name="Time (sec)", limits=c(dMin, dMax)) +
      labs(x="Total # Columns", y="Used # Columns", title=title) + 
      theme_bw()
}
```


```{r cache=TRUE, echo=F, results = 'hide', warning=F, message=F}

pltR <- gen_plot(dfReg, "Control")
pltP <- gen_plot(dfPlu, "Plugin")
pltLeg <- g_legend(pltR)

grid.arrange(pltR+guides(fill=FALSE), pltP+guides(fill=FALSE), pltLeg , ncol=3, widths=c(4,4,1))
```

    
```{r cache=TRUE,echo=F, results = 'asis', warning=F, message=F}
dfAll <- merge(x = dfReg, y = dfPlu, by = c("Tot", "Used"), all = FALSE)

ggplot(data=dfAll, aes(x=reorder(as.factor(Tot), Tot), y=reorder(as.factor(Used), Used), fill=(TimeMedian.y - TimeMedian.x)*100/TimeMedian.x)) +
    geom_tile(width=1, height=1) + 
    scale_fill_gradient2(low="green", mid="ivory", high="red", midpoint=0, name="Time %") +
    labs(x="Total # Columns", y="Used # Columns", title="Plugin performance vs control") + 
    theme_bw()
```

```{r cache=TRUE,echo=F, results = 'asis', warning=F, message=F}
```




#### Assumptions and Specifications

# Conclusion

